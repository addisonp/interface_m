import arrow
import bson
import datetime

from copy import deepcopy
from mongo_interface.util.config import GenConfig
from mongo_interface.util.mongo_utils import DbConnection


def update_smpte_flm_include_id(flm_dict: dict = {}, clear_all_id_keys_generated: bool = False,
                                lookup_collection=None, config: dict = None) -> None:
    """ Take a SMPTE FLM and a list of keywords and apply bson objectIDs to the corresponding elements

    :param dict flm_dict: the FLM
    :param bool clear_all_id_keys_generated: to remove all of the keys that would have been generated by this
    :param string lookup_collection: database name for the lookup table
    :param dict config: override configuration data
    :return: None
    :rtype None
    """

    # Review first it has the lookup db, if it does not have it return the same element
    if not lookup_collection:
        return flm_dict

    # Create connection to lookup Db.
    config = GenConfig(config=config)
    db = DbConnection(config['flm-db'])
    db_conn = db.conn()
    lookup_db_conn = db_conn[lookup_collection]

    stack = [flm_dict]
    while stack:
        o = stack.pop()
        if isinstance(o, dict):
            for key, val in o.items():
                # if o[key] is not None and type(o[key]) is list:
                if val is not None and type(val) is list:
                    for item in val:
                        if type(item) is dict:
                            keyword = key.split('List')[0].lower()
                            new_key = f'_{keyword}_id'
                            # override for same schema used
                            if keyword == 'nonsecuritydevice':
                                new_key = '_device_id'
                            if clear_all_id_keys_generated:
                                if new_key in item:
                                    item.pop(new_key, None)
                            else:
                                if new_key not in item:
                                    default_id = str(bson.ObjectId())
                                    if keyword in ['device']:
                                        default_id = update_device(item, default_id, lookup_db_conn)
                                    item[new_key] = default_id
                            stack.append(item)
                        elif type(item) is list:
                            stack.extend(item)
                elif type(val) is dict:
                    stack.append(val)
                else:
                    o[key] = cleanup_date_fields(key, val)
        elif isinstance(o, list):
            stack.extend(o)


def cleanup_date_fields(key, value):
    if key in ['last_modified', 'created_date']:
        return arrow.get(value).floor('second').datetime
    else:
        return value


def update_device(item: dict = [], default_id=None, lookup_db=None):
    make = item['Manufacturer']
    model = item['ModelNumber']
    serial = item['DeviceSerial']
    d_type = item['DeviceTypeID']

    lookup_match = lookup_db.device_lookup.find({'$and': [{'Manufacturer': make},
                                                          {'ModelNumber': model},
                                                          {'DeviceSerial': serial},
                                                          {'DeviceTypeID': d_type}]}
                                                )

    found_matches = lookup_match.count()
    if found_matches == 1:
        for l in lookup_match:
            default_id = l['_device_id']
    elif found_matches > 1:
        raise Exception(f'More than one match for a given make: {make},'
                        ' model: {model}, serial: {serial}, type: {d_type}')

    matching_trusted_device_id = None

    if not found_matches:
        insert_doc = {
            '_device_id': default_id,
            'Manufacturer': make,
            'ModelNumber': model,
            'DeviceSerial': serial,
            'DeviceTypeID': d_type,
            'trusted_device_id': matching_trusted_device_id,
            'update_date': datetime.datetime.utcnow(),
            'create_date': datetime.datetime.utcnow()
        }
        lookup_db.insert_one(insert_doc)
    return default_id


def parse_device_object_for_delta_population(flm_dict: dict = {}, parent={'name': 'start'}) -> dict:
    result_dict = {}
    parent = [parent]
    return_list = []
    # Setup the list of tuples
    get_recursive_keys(flm_dict, parent, return_list)
    # Fill the object with the data
    for tuple_info in return_list:
        parent_path = tuple_info[0]
        data = tuple_info[1]
        if parent_path[-1]['name'] in result_dict:
            if type(result_dict[parent_path[-1]['name']]) is dict:
                inside_info = result_dict[parent_path[-1]['name']]
                result_dict[parent_path[-1]['name']] = [inside_info]
            result_dict[parent_path[-1]['name']].append(data)
        else:
            result_dict[parent_path[-1]['name']] = data
    # Create a copy of dict to modify the content
    modified_object = deepcopy(result_dict)
    # Search for dicts to get in the parent dict
    for key, value in result_dict.items():
        if type(result_dict[key]) is dict and key != parent[-1]['name']:
            modified_object[parent[-1]['name']][key] = value
            del modified_object[key]

    return modified_object


def objectify_it(generator_item, result_dict):
    if type(generator_item) == tuple:
        parent_path = generator_item[0]
        data = generator_item[1]
        if parent_path[-1] in result_dict:
            if type(result_dict[parent_path[-1]]) is dict:
                inside_info = result_dict[parent_path[-1]['name']]
                result_dict[parent_path[-1]['name']] = [inside_info]
            result_dict[parent_path[-1]['name']].append(data)
        else:
            result_dict[parent_path[-1]['name']] = data
    else:
        for item in generator_item:
            objectify_it(item, result_dict)


def get_recursive_keys(input={}, parent=None, return_list_of_tuples=[]):
    parent_return_object = {}

    for key, value in input.items():
        if type(value) is dict:
            new_parent = deepcopy(parent)

            new_object = {'name': key}
            new_parent.append(new_object)

            get_recursive_keys(value, new_parent, return_list_of_tuples)
        elif type(value) is list:
            new_parent = deepcopy(parent)
            new_object = {'name': key}
            new_parent.append(new_object)
            return_object = {}

            for item in value:

                if type(item) == dict:

                    get_recursive_keys(item, new_parent, return_list_of_tuples)

                elif type(item) == list:
                    pass  # assumption we never have a list of list
                else:

                    return_object[key] = item
            if return_object:
                return_list_of_tuples.append((new_parent, return_object))

        else:
            if key.startswith('_') and key.endswith('_id'):
                parent[-1][key] = value
            parent_return_object[key] = value
    if parent_return_object:
        return_list_of_tuples.append((parent, parent_return_object))


def get_recursive_keys_node(input={}, parent=None, return_list_of_tuples=[]):
    parent_return_object = {}
    continue_process = {}

    for key, value in input.items():
        if type(value) is dict:
            continue_process[key] = value
        elif type(value) is list:
            continue_process[key] = value
        else:
            if key.startswith('_') and key.endswith('_id'):
                parent[-1][key] = value
            parent_return_object[key] = value
    if parent_return_object:
        return_list_of_tuples.append((parent, parent_return_object))

    for key, value in continue_process.items():
        if type(value) is dict:
            new_parent = deepcopy(parent)
            new_object = {'name': key}
            new_parent.append(new_object)
            get_recursive_keys_node(value, new_parent, return_list_of_tuples)
        elif type(value) is list:

            return_object = {}
            for item in value:
                new_parent = deepcopy(parent)
                new_object = {'name': key}
                new_parent.append(new_object)

                if type(item) == dict:
                    get_recursive_keys_node(item, new_parent, return_list_of_tuples)
                elif type(item) == list:
                    pass  # assumption we never have a list of list
                else:
                    if key not in return_object:
                        return_object[key] = [item]
                    else:
                        return_object[key].append(item)
            if return_object:
                return_list_of_tuples.append((new_parent, return_object))

        else:
            # this will never occur since the continue_process only holds dict/lists
            pass


def parse_device_object(flm_dict: dict = {}, parent='start') -> dict:
    """

    :param dict flm_dict:
    :return:
    :rtype dict
    """

    stack = [deepcopy(flm_dict)]
    return_data = {}
    empty_return_data = {}
    parent = [parent]

    while stack:
        o = stack.pop()
        if isinstance(o, dict):
            full_parent = o.pop('parent', parent)
            current_parent = full_parent[-1]

            for key, val in o.items():
                if val is not None and type(val) is list:
                    if key in return_data:
                        return_data[key].append(val)
                        empty_return_data[key].append(val)
                    else:
                        return_data[key] = val
                        empty_return_data[key] = val
                elif type(val) is dict:
                    if 'parent' in val:
                        val['parent'].append(key)
                    else:
                        val['parent'] = full_parent + [key]
                    stack.append(val)
                else:
                    nested_dict = (list_to_dict_keys(full_parent, {key: val}))
                    empty_nested_dict = (list_to_dict_keys(full_parent, {key: None}))
                    if len(full_parent) > 1:
                        add_to_dict(return_data, nested_dict)
                        add_to_dict(empty_return_data, empty_nested_dict)
                    else:
                        if current_parent in return_data:
                            return_data[current_parent].update({key: val})
                            empty_return_data[current_parent].update({key: None})
                        else:
                            return_data[current_parent] = {key: val}
                            empty_return_data[current_parent] = {key: None}
        elif isinstance(o, list):
            stack.extend(o)


def list_to_dict_keys(list_of_strings: list, leaf: dict):
    some_dict = deepcopy(leaf)
    for name in list_of_strings[::-1]:
        head = dict()
        head[name] = some_dict
        some_dict = head

    return head


def add_to_dict(return_data: dict, current_data: dict):
    for key, value in current_data.items():
        if return_data.get(key):
            add_to_dict(return_data.get(key), value)
        else:
            return_data[key] = value
